[concurrency](#concurrency)

[동시성 문제](#동시성-문제)

[임계 구역](#임계-구역)

[동시성 제어 조건](#동시성-제어-조건)

[동시성 문제 해결, 동기화 메커니즘 및 도구](#동시성-문제-해결-동기화-메커니즘-및-도구)

[예시 코드](#예시-코드)

## concurrency

독립적인 작업들 간에 시간을 분할하여 실행함으로써 동시에 실행되는 것처럼 보이도록 처리하는 능력을 말한다

이 때 여러 프로세스/스레드에서 공유 자원을 통해 작업을 처리하기 때문에 이에 대한 문제가 발생한다  

어떤 스레드의 특정 작업을 처리하기 위해 나머지 작업들이 기다려야 한다면 **해당 작업이 수행되지 않거나 점유하고 있는 자원(critical section)이 사용되지 않는 유휴 상태(idle status)**에 빠지게 된다

또한 **여러 프로세스/스레드에서 공유 자원에 접근하면 데이터의 일관성과 무결성이 깨지거나 작업의 수행 순서에 따라 결과가 달라지는 동시성 문제**가 발생할 수 있다

이러한 문제를 해결하기 위해 **각 작업에 대한 처리 시간을 분할**하여 유휴 상태에 빠지지 않게 하거나 자원에 특정 프로세스/스레드만 접근할 수 있도록 하는 **동기화**, **스레드 세이프 자료구조**, **원자적 연산**, **비동기 프로그래밍** 등의 해결책을 구현한다

동기화란 동시성을 제어하는 메커니즘을 말한다

## 동시성 문제

동시성 문제 원인
- 공유 자원(임계 구역)에 대한 동시 접근 
- 작업 간 수행 순서 불확실성


### 경쟁 상태 (race condition)

여러 프로세스/스레드가 공유 자원(같은 변수/객체 등)에 접근하고 수정하려고 할 때 발생하는 문제로 상태 불일치 문제를 초래한다 

#### 상태 불일치

공유 데이터의 상태가 일관성을 잃는 문제

동기화 처리를 통해 상태 불일치 문제를 해결할 수 있다

### 교착 상태 (deadlock)

둘 이상의 스레드가 서로에게 필요한 자원을 점유한 채로 무한 대기에 빠지는 문제

A 스레드가 자원 1을 소유하고 자원 2를 기다리는 중

B 스레드가 자원 2를 소유하고 자원 1을 기다리는 중

-> 두 스레드는 자원을 획득하기 위해 영원히 대기하는 상태에 빠진다


### 기아 상태 (starvation)

한 스레드가 자원을 지속적으로 점유하지 못해 작업이 무한히 지연되는 문제

우선순위가 낮은 스레드가 높은 우선순위의 스레드에게 계속 밀릴 때 발생되는 문제


### 활성화 지연 (livelock)

스레드가 서로를 기다리거나 자원을 양보하다가 무한히 작업을 진행하지 못하는 문제


## 임계 구역

임계 구역(critical section)이란 공유 자원에 접근하는 코드 블록으로 동시에 여러 스레드가 진입하면 데이터 경합이 발생하거나 데이터 무결성이 깨질 수 있는 부분을 의미한다

이를 해결하기 위해 동기화 메커니즘(임계 구역 보호)이나 동시성 알고리즘, 스레드 세이프 자료구조 등을 사용해서 동시성 문제를 해결한다

임계 구역 문제를 해결하려면 다음 조건(동기화 조건 또는 동시성 제어 조건)을 충족시켜야 한다

## 동시성 제어 조건

#### 1. 상호 배제 (mutual exclusion)

한 번에 하나의 스레드만 임계 구역에 진입할 수 있어야 한다

락 또는 뮤텍스를 사용하여 다른 스레드가 대기하도록 보장해야 한다

#### 2. 진행 (progress)

임계 구역에 진입하려는 스레드가 없으면(공유 자원을 사용하고 있는 스레드가 없으면) 대기 중인 스레드 중 하나가 반드시 임계 구역에서 작업을 진행할 수 있어야 한다

특정 스레드가 무한히 대기 상태에 빠지지 않도록 보장해야 한다

#### 3. 한정된 대기 (bounded waiting)

스레드가 임계 구역에 진입하기 위해 대기하는 시간이 유한해야 한다

특정 스레드가 [기아 상태](#기아-상태-starvation)에 빠지지 않도록 보장해야 한다

#### 4. 비선점 (non-preemption)

임계 구역에 진입한 스레드는 작업을 완료하고 자원을 해제하기 전까지 강제로 중단되지 않아야 한다

외부의 간섭없이 공유 자원을 점유한 스레드가 작업을 끝낼 수 있어야 한다


## 동시성 문제 해결, 동기화 메커니즘 및 도구

임계 구역을 보호하기 위한 동기화 처리를 적용하거나 동시성 문제를 우회할 수 있는 도구 

동기화 처리
- 경쟁 상태를 방지하기 위해 한 번에 하나의 스레드만 접근하도록 동기화 도구를 사용해 공유 자원을 보호한다
- 락

동시성 문제 우회
- 스레드 세이프 자료구조
- 원자적 연산
- 비동기 프로그래밍

### 락 (Lock)

소유권이 있어야 공유 자원에 접근할 수 있는 메커니즘

락을 획득한 스레드에서 공유 자원에 접근하고 나머지 스레드는 락을 획득하기 위해 대기한다

두 개 이상의 스레드가 대기를 해야 된다면 스레드 간 대기 순번을 정해야 하고, 락을 획득한 스레드는 컨텍스트 스위칭이 발생한다


### 뮤텍스와 세마포어


뮤텍스와 세마포어는 운영체제에서 제공하는 기본 동기화 메커니즘으로 [상호 배제](#1-상호-배제-mutual-exclusion) 조건을 달성하기 위한 기법으로 락을 기반으로 임계 구역에 대한 동기화 처리한다

뮤텍스 mutex (mutual exclusion)
- 뮤텍스는 자원의 상호 배제를 보장하는 락의 한 가지 형태로 소유권 개념이 존재한다
- 뮤텍스를 요청하여 락을 획득한 하나의 스레드만이 공유 자원에 접근하거나 락을 해제할 수 있다
- 해제된 락은 대기 중인 다음 스레드가 소유권을 획득한다
- 파일 쓰기, 메모리 수정 등에서 사용

세마포어 (semaphore)
- 세마포어는 공유 자원에 동시에 접근할 수 있는 스레드 허용 개수(permit)를 제한하여 동시 접근이 가능한 동기화 방법이다
- 자원에 접근하려는 스레드는 permit을 요청(acquire)하고, 자원 사용이 끝나면 permit을 반환한다(release)
- 모든 permit을 사용 중이면 다른 스레드들은 대기한다
- 뮤텍스에 비해 소유권 개념이 약해서 반환하는 스레드가 반드시 permit을 획득한 스레드일 필요가 없다
- DB 커넥션 풀, 네트워크 요청 처리 등에서 사용


### 모니터

운영 체제 또는 프로그래밍에서 동시성 제어를 위해 뮤텍스와 기타 메커니즘을 조합하여 [경쟁 상태](#경쟁-상태-race-condition)를 해결하기 위해 사용된다

임계 구역은 뮤텍스로 보호하고 스레드 간 동기화를 지원하기 위해 조건 변수를 사용한다

운영 체제에서는 커널 수준의 모니터가 사용된다
- 커널은 프로세스 간 통신(IPC)을 위해 모니터를 활용하며 뮤텍스와 세마 포어를 사용해 구현된다

#### 조건 변수 (condition variables)

멀티 스레드 환경에서 스레드 간의 통신을 가능하게 해주는 동기화 도구

스레드가 특정 조건을 충족할 때까지 기다리거나 조건이 충족되었음을 다른 스레드에게 알리는 데 사용된다

역할
- 대기(wait): 조건이 충족될 때까지 스레드를 대기 상태로 전환
- 알림(signal/broadcast): 조건이 충족되었음을 대기 중인 스레드에게 알림

signal: 대기 중인 하나의 스레드만 깨운다

broadcast/signalAll: 대기 중인 모든 스레드를 깨운다


### 스핀 락


특정 공유 자원에 대해 락을 얻기 위해 스레드가 계속해서 루프를 돌며 락 상태를 확인하며 대기하는 방식이다

스레드가 바쁘게 대기(busy waiting)하는 특징이 있다

#### 스핀 락 동작
1. 스레드가 자원에 대한 락 획득 시도
2. 락이 이미 다른 스레드에 의해 점유된 상태라면, 해제될 때까지 루프를 돌며 상태 확인
3. 락이 해제되면 스레드는 즉시 락을 획득하고 임계 구역 진입

스핀 락을 사용하면 스레드가 대기 상태로 전환되지 않고 CPU를 계속 사용하기 때문에 컨텍스트 스위칭 비용이 발생하지 않는다 

보통 짧은 시간이 소요되는 임계 구역에서 유리하며 싱글 코어보다 멀티 코어 환경, 운영 체제 커널, 저수준 동기화에서 사용된다

여러 스레드가 동시에 스핀 락을 시도할 경우 특정 스레드가 락을 오랫동안 획득하지 못하거나 교착 상태에 빠져 CPU 자원을 낭비할 가능성이 생긴다


### 원자적 연산, CAS (Compare-And-Swap)

멀티스레드 환경에서 락을 사용하지 않고(락 프리) 공유 자원을 안전하게 업데이트할 수 있는 CPU 차원에서 지원되는 하드웨어 동기화 기법이다

CAS는 세 가지 값을 사용한다
- **메모리 주소(location, offset)**: 수정하려는 값이 저장된 메모리 위치
- **기대 값(expected)**: 메모리 주소에 저장되어 있어야 한다고 기대하는 값
- **새 값(new value)**: 메모리 주소에 저장하려는 값

연산 순서
- 메모리에 있는 값을 기대 값과 비교한다
- 기대 값과 메모리 값이 같으면 메모리 값을 새 값으로 교체한다
- 다르다면 교체하지 않고 실패를 반환한다

위의 과정을 하드웨어 명령으로 수행하므로 원자적으로 실행되며 락 기반의 동기화보다 대기 시간이 짧고 컨텍스트 스위칭이 필요없기 때문에 상대적으로 높은 성능을 가진다

#### CAS의 단점

ABA 문제
- 메모리 값이 변경되었다가 다시 원래 값으로 돌아오는 경우 인식하지 못한다
- 값 변경: A -> B -> A (CAS는 값이 변하지 않았다고 판단한다)
- 이를 해결하기 위해 값과 함께 변경 버전을 저장하여 검증한다

busy spinning
- CAS는 실패 시 값을 계속 비교하므로 실패가 반복되면 CPU 리소스를 낭비할 수 있다
- 스핀 락처럼 동작하며 경쟁이 심할수록 성능이 저하된다

복잡한 값 변경의 어려움
- 단일 메모리 위치의 값을 교체하는 연산에는 좋은 성능을 내지만 복잡한 로직에는 적합하지 않다

## 예시 코드

[경쟁 상태 테스트 코드(자바)](./src/java/src/test/java/concurrency/RaceConditionTest.java)