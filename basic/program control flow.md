[Main Routine](#main-routine)

[Subroutine](#sub-routine)

[Corutine](#corutine)

[Corutine vs Thread](#corutine-vs-thread)

[언어 별 코루틴](#언어-별-코루틴)


## Main Routine


**프로그램의 진입점** 

기본 실행 단위로 main() 함수/메서드에 해당한다


#### 제어 흐름


프로그램의 시작과 끝을 정의하는 프로그램 실행의 루트가 된다

단방향 실행 흐름을 가진다 (시작 -> 끝)

다른 하위 루틴(서브루틴, 코루틴)을 호출하여 작업을 위임하고, 종료 후 제어를 다시 받는다


#### 상태 관리


프로그램 전역 상태를 초기화하거나 관리한다


#### 병렬 처리


메인 루틴 자체는 단일 스레드에서 실행된다

병렬 처리는 스레드, 이벤트 루프 또는 다른 루틴에서 수행한다


#### 예시 코드


```java
class Routine {

    public static void main(String args[]) {
        System.out.println("running main routine);
    }
}
```






## Subroutine

[made by](https://ko.wikipedia.org/wiki/%EC%97%90%EC%9D%B4%EB%8B%A4_%EB%9F%AC%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%8A%A4)


**특정 작업이나 연산을 수행하기 위해 호출되는 재사용 가능한 코드 블록**

함수, 메서드, 프로시저가 서브 루틴에 해당된다

코드 중복 제거 및 모듈화하여 프로그램을 구조화할 수 있다


#### 제어 흐름


호출(call)-복귀(return) 실행 흐름을 가진다

재귀 호출 가능: 서브 루틴이 자기 자신을 호출하여 반복 작업을 수행할 수 있다

호출되면 작업 수행 -> 호출한 루틴으로 제어 반환


#### 상태 관리


호출될 떄 전달받은 인자나 지역 변수를 사용한다

함수형 프로그래밍에서는 서브 루틴에서 전역 상태를 변경하는 것을 지양한다


#### 병렬 처리


서브 루틴 자체는 단일 스레드에서 동작한다

병렬 작업은 서브 루틴 내부에서 스레드, 태스트를 생성하여 처리한다


#### 예시 코드


```java
class Calculator {


    public static void main(String args[]) {
        int result = add(1, 1);

        System.out.println("result: " + result);
    }

    private static int add(int a, int b) {
        return a + b;
    }

}
```





## Corutine


**실행을 중단하고 다른 루틴으로 제어를 넘겼다가 다시 복귀할 수 있는 루틴**

병렬 처리, 이벤트 루프, 비동기 I/O 작업같은 병렬/비동기 프로그래밍에서 유용하다

`async/await` `yield`와 같은 키워드로 구현된다


#### 제어흐름


현재 루틴을 일시중단하고 다른 곳의 작업으로 전환했다가 중단된 지점에서 실행 흐름을 재개할 수 있다

`yield` `await` 같은 키워드를 사용하여 실행의 흐름(중단/재개)을 제어한다

협력적 실행(cooperative execution)을 통해 제어를 공유한다


#### 상태 관리


**상태를 유지한 채로 루틴을 중단/재개**할 수 있다

상태 변경은 코루틴 지역 상태에만 한정되며 전역 상태를 변경하지 않는 것을 지향한다


#### 병렬 처리


비동기/병렬 작업에 적합하다

상태를 공유하지 않아 동시 실행 중 데이터 동기화 문제를 줄인다 -> 공유 상태 없이 독립적으로 실행할 수 있다


#### 예시 코드




## Corutine vs Thread 


### 스레드


운영체제 수준에서 관리되는 프로그램 실행 단위 



#### 스레드 기반 동시성 모델


스레드를 통해 프로그램 실행 흐름을 제어하는 방식, 운영체제가 스케줄링한다


콜백을 이용한 비동기 프로그래밍은 코드가 복잡해지고 가독성이 떨어지는 단점이 있다

특징
- 컨텍스트 스위칭: 운영체제는 스레드 컨텍스트 스위칭을 통해 동시성을 지원하는데, 이 과정에서 CPU 레지스터와 캐시를 저장하고 복구하므로 큰 비용을 소모한다
- 자원 공유: 여러 스레드가 같은 메모리 공간과 자원을 공유하므로, 공유 상태를 다룰 때 동기화(Synchronizatino) 기법이 필요하다
- 블로킹 연산: I/O 작업(파일 I/O, 네트워크 요청 등) 중 스레드가 대기 상태에 들어가면, 해당 스레드는 아무 작업도 하지 않고 자원을 차지한다


### 코루틴


언어, 런타임에서 관리하는 경량 실행 단위(함수/메서드), 언어/프레임워크가 협력적 스케줄링(cooperative scheduling)을 수행한다

코루틴은 작업의 상태를 저장하고 필요할 때 중단한 지점에서 재개할 수 있으므로 더 효율적이고 직관적이다


#### 협력젹 스케줄링

명시적인 `yield` `suspend` 키워드를 통해 코루틴 스스로 실행을 멈추고 제어권을 넘기는 방식

#### 코루틴 기반 동시성 모델


코루틴을 통해 프로그램 실행 흐름을 제어하는 방식 -> 컨텍스트 스위칭 비용 감소(스레드보다 낮은 비용으로 동시성 지원)

협력적 스케줄링을 사용해서 코루틴 스스로가 명시적으로 제어를 넘기면서 실행된다

코루틴은 대기(I/O 등) 상태에서도 다른 작업을 수행할 수 있고, 비동기 작업을 동기 코드처럼 간결하게 작성할 수 있어서 비동기 프로그래밍에 적합하다


## 언어 별 코루틴


### Java


자바는 언어적 한계로 인해 코루틴을 구현할 수 없다

코루틴을 구현하려면 중단한 스택 프레임과 상태를 저장했다가 복원할 수 있어야 하는데 자바는 스택 기반 호출, 스레드 기반 동시성 모델을 사용하고 있기 때문에 JVM 레벨에서 이러한 기능이 지원되지 않는다


**스택 기반 호출**: 각 메서드 호출이 호출 스택에 쌓이고, 끝나면 스택에서 제거되는 방식


#### 자바의 스레드 모델 사용


```java
Thread thread = new Thread(() -> {
    System.out.println("new thread !");
});

thread.start();
```

```java
ExecutorService executor = Executors.newFixedThreadPool(10);

executor.submit(() -> {
    System.out.println("Task executed in thread pool");
});

executor.shutdown();
```

자바의 스레드는 운영체제가 관리하는 물리적 스레드와 직접 연결된다

JVM이 직접 운영체제 스레드를 생성하고 스케줄링하며, 애플리케이션은 이 스레드를 활용해 병렬 작업을 수행한다


#### Project Loom


자바는 코루틴과 스레드를 융합하여 기존 스레드 기반 모델을 보완하며 코루틴 장점을 통합하려고 하는 Project Loom을 진행하고 있다

Project Loom의 핵심은 코루틴처럼 동작하는 Virtual Thread이다

Virtual Thread
- JVM에서 관리하는 경량 스레드
- OS 스레드와 직접 연결되지 않는 대신 다수의 Virtual Thread가 소수의 OS 스레드에서 실행된다 (M:N 매핑)
- 자원 공유: JVM이 상태(레지스터, 호출 스택 등)를 관리하며 필요 시 상태를 저장하고 재개한다
- 블로킹 연산: 블로킹 호출(I/O 등)에서 OS 스레드를 점유하지 않고 다른 Virtual Thread로 작업을 전환하다
- 기존 스레드 API와 호환된다 (기존 동기적 프로그래밍 모델과의 호환성 유지)


다만 코루틴과 완전히 동일한 개념이 아니다



#### 코루틴과 Virtual Thread 차이점


구현 수준
- 코루틴: 언어와 런타임 수준
- Virtual Thread: JVM 수준


스케줄링
- 코루틴: [협력적 스케줄링](#협력적-스케줄링)
- Virtual Thread
    - OS 스레드의 선점형 스케줄링 활용
    - JVM에서 상태를 관리하지만 실행 시점에는 여전히 OS 스레드 스케줄링에 의존하지만(기존 스레드 API를 그대로 사용하므로) OS 스레드와 1:1로 매핑되지 않고 소수의 OS 스레드에서 실행된다


상태 관리
- 코루틴: 언어 런타임 또는 컴파일러
- Virtual Thread: JVM

제어 흐름
- 코루틴: suspend, yield 등 키워드를 통한 명시적 제어
- Virtual Thread: 기존 자바 스레드처럼 동작


OS 스레드 사용 여부
- 코루틴: 사용 X
- Virtual Thread: OS 스레드와 독립적이지만, 다수의 Virtual Thread가 소수의 OS 스레드에서 실행된다


### Python


비동기 프로그래밍의 aysnc/await 키워드 도입

asyncio


### Kotlin

언어 차원의 코루틴 지원


### JavaScript

Promise (ES6)

async/await (ES8)

### Go

Gorotine

