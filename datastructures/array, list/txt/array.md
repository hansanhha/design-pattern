## 특징

배열은 선형 자료구조이며 메모리에 인접한 공간에 **연속적**으로 요소를 저장함

배열의 인덱스는 각 요소에 접근할 수 있는 포인트로 물리적인 메모리 주소에 대응됨

**요소 접근**

첫 인덱스는 첫 요소를 가리키는 배열의 시작점임

요소에 접근하기 위해 메모리 공간의 값을 도출하는 식은 다음과 같음

`첫 인덱스 메모리 주소 + 요소 길이 * 요소 인덱스`

만약 첫 인덱스의 메모리 주소가 0이고, int 배열의 인덱스 5에 위치한 요소에 접근하는 경우라면

0 + 4 * 5 = 20

배열은 인덱스를 통해 요소에 직접적으로 접근할 수 있기 때문에 (**랜덤 억세스**) `O(1)`의 시간 복잡도를 가짐

**요소 찾기**

배열에서 요소를 찾으려면 순회를 돌며 값을 비교해야 됨

이 방식을 선형 검색(linear search)이라고 함

```java
int find(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == target)
            return i;
    }
    return -1;
}
```

**삽입**

삽입하려는 인덱스부터 그 뒤까지 요소가 존재한다면

해당 요소들을 모조리 뒤로 한 칸씩 밀어서 공간을 만들어줘야 됨

그리고 맨 마지막 요소는 더 이상 담아둘 공간이 없기 때문에 그 전 요소에 의해 값이 덮어씌워짐

**삭제**

삭제하려는 인덱스의 뒤에 요소가 존재한다면

해당 요소들을 모조리 앞으로 한 칸씩 당겨줘야 됨

**배열 삽입, 삭제 연산의 단점**

삽입, 삭제 시 요소들을 한 칸씩 이동시켜야 하므로 `O(n)`의 시간 복잡도를 가짐

배열의 길이는 고정되므로 삽입 시, 초과되는 요소들은 값을 잃어버리게 됨

**확장**

배열은 한 번 초기화되면 더 이상 길이를 늘릴 수 없음

만약 배열을 늘리고 싶다면 

더 긴 길이를 가진 새로운 배열을 만들고 원래의 배열의 값들을 복사해야 됨 - `O(n)`

## 장점

**공간 절약**

메모리 공간에 순차적으로 데이터를 위치하기에 요소의 위치를 나타내기 위한 오버헤드가 발생하지 않음

**랜덤 억세스**

어느 요소에 접근하던지 `O(1)`의 시간을 보장함

**캐시**

배열 요소에 접근할 때, 컴퓨터는 해당 데이터를 읽을 뿐만 아니라 주변 데이터도 캐시하여 작업 속도를 향상 시킴

## 단점

**삽입, 삭제의 비효율**

삽입, 삭제는 다른 배열 요소들의 이동을 필요로 함

**고정된 길이**

한 번 초기화된 배열은 고정적이며, 새로운 긴 배열을 만들려면 순차적으로 돌며 값을 할당해야 하는 비용이 발생함

**공간 낭비**

초기화된 길이에 비해 사용하는 요소가 적다면 남은 공간은 의미없이 메모리 공간을 차지하고만 있게 됨

## 사용

정렬/검색 알고리즘
- 퀵 정렬, 머지 정렬, 이진 검색 등에서 배열 사용

머신 러닝
- 벡터, 행렬, 텐서 등 선형 대수 연산을 실행하는 데 배열이 사용됨

자료구조 구현
- 스택, 큐, 해시 테이블, 힙, 그래프
- 그래프의 인접 행렬은 본질적으로 2차원 배열임
