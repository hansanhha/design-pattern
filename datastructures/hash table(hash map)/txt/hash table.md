[해시 테이블](#해시-테이블)

[해시 테이블 구성 요소](#해시-테이블-구성-요소)

[해시 테이블 기본 작업](#해시-테이블-기본-작업)

[해시 함수](#해시-함수)

[해시 충돌](#해시-충돌)

[해시 알고리즘](#해시-알고리즘)

## 해시 테이블

해시 테이블은 해시 맵이라고도 하는데, 키와 값이 매핑된 데이터를 저장하는 자료구조임

해시 테이블의 강점은 일반적인 배열이나 연결 리스트가 수행하는 작업의 시간 복잡도에 비해 훨씬 빠른 속도를 가짐

**시간 복잡도**

|  작업  |  배열  | 연결 리스트 | 해시 테이블 |
|:----:|:----:|:------:|:------:|
|  검색  | O(n) |  O(n)  |  O(1)  |
|  삽입  | O(1) |  O(1)  |  O(1)  |
|  삭제  | O(1) |  O(1)  |  O(1)  |

## 해시 테이블 구성 요소

해시 테이블은 다음과 같은 자료구조로 구현될 수 있음
- 배열
- 트리
- 연결 리스트

<img src="../images/hash table structure.png" alt="hash table structure" style="width: 70%; height: 70%">

[출처](https://www.hello-algo.com/en/chapter_hashing/hash_map/#612-simple-implementation-of-a-hash-table)

**해시 테이블의 구성 요소**
- 버킷: 해시 테이블에서 사용할 수 있는 공간(엔트리가 존재하지 않는 공간)
- 엔트리: 키-값 쌍의 데이터
- 해시 함수: 해시 테이블에서 엔트리를 저장하고, 값을 찾는 등의 작업을 수행하는 데 필요한 연산
- 로드 팩터: 해시 테이블의 성능을 평가하고, 필요에 따라 크기를 조정하기 위해 사용되는 요소

## 해시 테이블 기본 작업

[해시 테이블 기본 작업 코드](./python/simple_using_hash_map.py)

**초기화**

해시 테이블을 생성하는 작업

**삽입**

키 값과 값을 삽입하는 작업

**삭제**

키 값을 기반으로 엔트리(키-값 쌍)를 삭제하는 작업

**검색**

키 값을 기반으로 값을 찾는 작업

**순회**

3가지 방식으로 순회 가능

1. 엔트리(키-값 쌍) 루프
2. 키
3. 값

## 해시 함수

배열이 인덱스를 이용해서 메모리 공간에 랜덤 액세스를 할 수 있는 것처럼 해시 테이블도 키를 이용해서 버킷의 위치에 접근할 수 있음

키는 메모리 공간에 대응되는 오프셋도 아닌데 어떻게 버킷의 위치를 찾을 수 있을까?

해시 함수의 입력 값으로 키를 넣고 계산된 값을 통해 버킷의 위치를 찾는 거임

해시 함수를 통해 버킷의 위치를 찾는 과정은 다음과 같음
1. 키 값이 주어지면, 특정 해시 알고리즘을 적용한 해시 값을 계산함
2. 해시 값과 버킷의 수(capacity)를 통해 인덱스를 구함  
3. 구한 인덱스를 통해 버킷에 접근하여 작업 수행

[배열로 구현된 해시 테이블](/python/array_hash_map.py)

## 해시 충돌

해시 함수를 통해 인덱스를 구할 때 서로 다른 key 값이, 동일한 output을 내는 상황을 **해시 충돌**이라고 함

해시 충돌이 발생하면 서로 다른 키 값으로 동일한 버킷에 접근할 수 있기 때문에 부정확한 결과가 발생함

따라서 해시 충돌에 대한 대처 방법이 필요한데 크게 2가지가 있음
- 해시 충돌이 발생한 상황을 대처하는 방법 
- 해시 테이블 크기를 늘려서 충돌 범위를 줄이는 방법

### 해결 방안 1. 해시 충돌 대처

해시 충돌을 대처하기 위한 방식으로 해시 테이블의 각 버킷의 자료구조를 개선하는 방법과 해시 값을 구하는 방식을 개선하는 방법이 있음

#### Separate Chaining

<img src="../images/hash-table-separate-chaining.png" alt="hash table separate chaining" style="width: 80%; height: 80%"/>

각 버킷에 하나의 엔트리를 저장하는 기본적인 해시 테이블과 달리, 새로운 자료구조를 도입하여 하나의 버킷에 여러 개의 엔트리를 저장하는 방식임

버킷에 사용되는 자료구조는 연결 리스트나 균형 이진 탐색 트리인 AVL 트리 또는 Red-Black 트리를 사용하는 편임

충돌이 발생해도 연결 리스트 같은 자료구조를 통해 동일한 버킷에 여러 개의 엔트리를 저장 또는 접근할 수 있게 됨

Separate Chaining 방식을 사용하면 기본 작업이 다음과 같이 변경됨
- **검색**
  - 해시 함수를 통해 버킷 인덱스를 얻음 (기존과 동일)
  - 연결 리스트의 헤드 노드부터 순회를 하면서 각 노드의 key 값과 입력 key 값을 비교해서 엔트리를 찾음
- **삽입**
  - 마찬가지로 해시 함수를 통해 버킷 인덱스를 얻음
  - 연결 리스트 헤드 노드에 접근해서 노드(엔트리)를 삽입함
- **삭제**
  - 마찬가지로 해시 함수를 통해 버킷 인덱스를 얻음
  - 연결 리스트의 헤드 노드부터 순회를 하면서 각 노드의 key 값과 입력 key 값을 비교해서 엔트리를 찾은 뒤 삭제함

다음과 같은 한계점이 있음
- **메모리 사용량 증가**
  - 연결 리스트를 사용하므로 일반적인 배열보다 더 많은 메모리 공간을 필요로 함
- **검색 효율성 하락**
  - 해시 함수를 사용한다고 하더라도, 원하는 엔트리를 찾으려면 연결 리스트의 선형 탐색이 필요함 `O(n)`

그래서 성능 최적화를 위해 연결 리스트 대신 **AVL 트리** 또는 **Red-Black 트리**를 사용하면 시간 복잡도를 `O(log n)` 까지 줄일 수 있음  

#### Open Addressing

Open Addressing은 새로운 자료구조를 도입하지 않고 일반적인 해시 테이블과 동일하게 한 개의 버킷에는 한 개의 엔트리만 저장함

대신 비어 있는 버킷의 위치를 구해서 충돌을 회피하는 방식임

이걸 다중 프로빙(Multi Probing)이라고 하는데, 프로빙엔 주로 아래의 방법들이 포함됨
- 선형 탐색(Linear Probing)
- 제곱 탐색(Quadratic Probing)
- 이중 해싱(Double Hashing)

##### Linear Probing

비어있는 버킷을 찾을 때까지 순회하는 방식

- **삽입**
  - 해시 충돌 발생 시, 발생 지점부터 비어있는 버킷을 찾을 때까지 순회(일반적으로 한 칸씩 이동)하여 삽입
- **검색**
  - 해시 충돌 발생 시, 삽입 시 순회했던 동일한 크기로 이동하며 엔트리를 찾으려고 시도
  - 찾았다면 엔트리의 값을 반환하고, 다음 위치가 빈 버킷이라면 대상 엔트리가 해시 테이블에 없음을 의미하므로 `None`을 반환함

**선형 탐색의 단점**

선형 탐색을 사용하면 해시 충돌된 키들이 비슷한 공간에 모이게 됨(클러스터링을 하기 쉬움)

배열 같이 연속적으로 메모리를 점유하는 경우, 연속적인 위치에서 해시 충돌이 발생할 확률이 높아져서 해당 위치에서

클러스터링이 더 촉진되고 악순환이 발생하여 삽입, 삭제, 검색 등 작업의 효율성을 저하시킬 수 있음

**주의점**

선형 탐색을 사용하는 해시 테이블의 경우 직접적으로 엔트리를 삭제하면, 삭제된 빈 버킷에 `None` 처리를 하게 됨

이 때 선형 탐색을 이용해서 값을 검색할 때, 삭제된 버킷의 None을 맞닥뜨리면 해시 테이블에 값이 없다고 판단하고 이후의 엔트리는 읽지 않고 `None`을 반환함

그래서 직접적으로 요소를 삭제하지 않고 해당 엔트리에 `TOMBSTONE`이라는 삭제된 상태임을 마킹하는 "lazy deletion" 메커니즘을 사용하는 방법이 있음

이 방법을 사용하면 선형 탐색을 하다가 `TOMESTONE` 엔트리를 보면 스킵하고 다음으로 넘어감

다만 이것도 성능 저하를 유발하는데, `TOMBSTONE` 엔트리가 계속 생기면 선형 탐색 시 스킵하는 엔트리가 많아져서 검색 시간이 느려짐

이 경우엔, 선형 탐색 시 첫 번째로 마주친 `TOMESTONE` 엔트리와 검색된 대상 엔트리의 위치를 서로 바꿔줌으로써 삭제되지 않은 엔트리를 효율적인 공간으로 옮겨서 최적화할 수 있음 

##### Quadratic Probing

순차적으로 순회하며 빈 공간을 찾는 Linear Probing과는 약간 다르게, 각 순회하는 횟수에 따라 제곱(1,4,9...)하여 버킷을 찾는 방식임

**제곱 탐색의 장점**

선형 탐색의 클러스터링 효과가 비교적 완화됨

버킷의 간격을 넓게 스킵하기 때문에 데이터를 더 균등하게 분배하는 데 도움이 됨

**주의점**

여전히 클러스터링 문제가 존재함

제곱의 증가로 인해 전체 해시 테이블을 탐색하지 못할 수도 있음 (빈 버킷이 있더라도, 그곳에 접근할 수 없는 경우가 생김)

Linear Probing의 삭제 기능 문제점을 똑같이 가지고 있음

##### Double Hashing

이름에서 알 수 있듯이 빈 버킷을 찾을 때 까지 여러 번 해시 함수를 사용하는 방식임

- **삽입**
  - 삽입 시 충돌이 발생한 경우 빈 버킷을 찾을 때 까지 해시 함수를 사용하고, 빈 버킷을 발견한다면 삽입
- **검색**
  - 삽입할 때 사용했던 해시 함수를 순서대로 사용해서 버킷을 찾으려고 시도
  - 해시 함수를 사용하던 도중 빈 버킷을 만난 경우, 해당 엔트리가 테이블에 없다고 간주하고 None 반환 
  - 모든 해시 함수를 사용했는데 찾지 못한 경우에도, None 반환

Linear Probing, Quadratic Probing에 비해 클러스터링이 덜 발생하지만, 해시 함수를 여러 번 사용하여 오버헤드를 증가시킴

**주의점**

Linear Probing의 삭제 기능 문제점을 똑같이 가지고 있음

### 해결 방안 2. 해시 테이블 크기 증량

해시 테이블의 크기를 늘리면 충돌 범위가 적어질 수 있지만

해시 테이블의 크기를 늘리는 과정에서 기존의 엔트리를 그 위치에 다시 옮기기 위해 모든 엔트리에 대한 **해시 코드를 재계산** 해야 되는 오버헤드가 발생함

크기 조정에 따른 오버헤드를 줄이기 위해 두 가지 방법을 사용함
- 빈번한 크기 조정을 막기 위해 초기에 넉넉한 용량을 할당함
- 엔트리 수/버킷 수의 비율을 나타내는 **load factor** 를 통해 필요에 따라 크기를 조정함
  - 비율이 1에 가까울수록 테이블이 거의 꽉 찬 것을 의미함 - 충돌 발생 가능성 높아짐

그래도 여전히 크기를 늘리는 과정에서 오버헤드가 발생하므로 크기 증량은 최후의 수단으로 사용하는 게 좋음

## 해시 알고리즘

|   |   MD5    |  SHA-1  |  SHA-2  |  SHA-3  |
|---|:--------:|:-------:|:-------:|:-------:|
| output 길이| 128 bit  | 160 bit| 256/512 bit| 224/256/384/512 bit|
| 사용 | 거의 안씀, 데이터 무결성 확인할 때 사용 | 거의 안씀 | 암호화폐  거래, 전자서명 등 | SHA-2와 동일 |
